<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <meta name="viewport" content="width=device-width, user-scalable=no" />

    <title>Tekniska test</title>
    <!-- <link rel="stylesheet" href="./styles.css" /> -->
    <style>
      body {
        background-color: #ea6464;
        color: #333;
        width: 100%;
        height: 100%;
        overflow: hidden;
        user-select: none !important;
        text-align: center;
      }
      select,
      button,
      input {
        display: block;
        height: 50px;
        width: 250px;
        font-size: 25px;
        margin: 10px auto;
      }
      #start {
          background-color: rgb(96, 219, 96);
          border-radius: 50%;
          color: white;
          box-shadow: 0px 0px 10px 5px rgba(0, 0, 0, 0.1);
          height: 15vw;
          width: 15vw;
          position: absolute;
          left: 30%;
      }
      #speed-input {
          height: 80vh;
          width: 5vw;
      }
      #speed-input-div {
          position: absolute;
      }
      canvas {
          position: absolute;
          top: 0;
          left: 0;
      }
    </style>
  </head>

  <body>
    <div class="body">
      <div id="speed-input-div">
      <label for="speed-input"
        >Speed
        <input
          type="range"
          min="0"
          max="10000"
          value="1"
          orient="vertical"
          id="speed-input"
        /> </label
      >
      </div>
      <br />
      <button id="start">START</button>
    </div>
    <script src="./js/libraries/socket.io.min.js"></script>
    <script src="./js/libraries/p5.min.js"></script>
    <script src="./js/button_map.js"></script>

    <script>
      const socket = io();
      document.getElementById("start").addEventListener("click", () => {
        socket.emit("capture");
      });
      document
        .getElementById("speed-input")
        .addEventListener("input", function () {
          socket.emit("speed",  Math.pow(this.value/10000.0, 3) * 10000.0);
        });
    </script>
    <script>
      let encoder = {
  x: 0,
  y: 0,
  rotation: 0,
  touch_angle: 0,
  size: 200,
  dip_size: 20,
  dip_offset: 0.8,
  update_rotation: function(x, y) {
    // calculate the angle of the mouse position and change rotation the amount of the difference since the last angle
    let new_touch_angle = atan2(this.x-x, y-this.y);
    let change = new_touch_angle - this.touch_angle;
    // Keep the change within -PI >= change >= PI so that there isn't a sudden jump
    // in the sign of the change. This avoids discontinuities.
    if (change > PI) {
      change -= TAU;
    }
    if (change < -PI) {
      change += TAU;
    }
    if(change > 0.2) {
      this.rotation += change;
      this.touch_angle = new_touch_angle;
      socket.emit("step");
    }
  },
  draw: function() {
    fill(255);
    ellipse(this.x, this.y, this.size, this.size);
    let dip_offset = this.size * this.dip_offset * 0.5;
    let dip_x = this.x + (cos(this.rotation) * dip_offset);
    let dip_y = this.y + (sin(this.rotation)* dip_offset);
    fill(10);
    ellipse(dip_x, dip_y, this.dip_size, this.dip_size);
    ellipse(this.x, this.y, this.size*0.01, this.size*0.01);
  }
};

let setting_wheel = {
  x: 0,
  y: 0,
  rotation: 0,
  pull_rotation: 0,
  touch_angle: 0,
  size: 200,
  dip_size: 20,
  dip_offset: 0.8,
  num_options: 6,
  option_names: ["contrast", "saturation", "invert", "brightness", "sepia", "colorFilter"],
  update_rotation: function(x, y) {
    // calculate the angle of the mouse position and change rotation the amount of the difference since the last angle
    let new_touch_angle = atan2(this.x-x, y-this.y);
    let change = new_touch_angle - this.touch_angle;
    // Keep the change within -PI >= change >= PI so that there isn't a sudden jump
    // in the sign of the change
    if (change > PI) {
      change -= TAU;
    }
    if (change < -PI) {
      change += TAU;
    }
    let option_rotation = TAU/this.num_options;
    if(abs(change) > option_rotation) {
      this.rotation += max(min(change, option_rotation), -option_rotation);
      this.rotation %= TAU;
      this.touch_angle = new_touch_angle;
      let option = (this.rotation * this.num_options) / TAU;
      while(option < 0) {
        option += this.num_options;
      }
      socket.emit("filter", this.option_names[option]);
    } else {
      this.pull_rotation = change * 0.1;
    }
  },
  draw: function() {
    fill(255);
    strokeWeight(1);
    ellipse(this.x, encoder.y, this.size, this.size);
    let rotation = this.rotation + this.pull_rotation;
    let arrow_offset = this.size * this.dip_offset * 0.5;
    let dir = createVector(cos(rotation), sin(rotation));
    let arrow_x1 = this.x + (dir.x * arrow_offset*0.5);
    let arrow_y1 = this.y + (dir.y * arrow_offset*0.5);
    let arrow_x2 = this.x + (dir.x * arrow_offset);
    let arrow_y2 = this.y + (dir.y * arrow_offset);
    strokeWeight(3);
    line(arrow_x1, arrow_y1, arrow_x2, arrow_y2);
    let dir_back = createVector(cos(rotation-0.2), sin(rotation-0.2));
    let dir_front = createVector(cos(rotation+0.2), sin(rotation+0.2));
    let arrow_x3 = this.x + (dir_back.x * arrow_offset*0.8);
    let arrow_y3 = this.y + (dir_back.y * arrow_offset*0.8);
    let arrow_x4 = this.x + (dir_front.x * arrow_offset*0.8);
    let arrow_y4 = this.y + (dir_front.y * arrow_offset*0.8);
    line(arrow_x2, arrow_y2, arrow_x3, arrow_y3);
    line(arrow_x2, arrow_y2, arrow_x4, arrow_y4);
    fill(10);
    strokeWeight(1);
    ellipse(this.x, this.y, this.size*0.01, this.size*0.01);
    push();
    translate(this.x, this.y);
    let option_rotation = TAU/this.num_options;
    for (let i = 0; i < this.num_options; i++) {
      rotate(option_rotation);
      line(this.size*0.6, 0, this.size*0.8, 0);
      textSize(20);
      text(this.option_names[i], this.size*0.8, 0);
    }
    pop();
  }
}

let fader = {
  x: 0,
  y: 0,
  
}

function setup() {
  createCanvas(window.innerWidth, window.innerHeight);
  encoder.size = height * 0.7;
  encoder.x = width*0.7;
  encoder.y = height/2;
  setting_wheel.size = height * 0.2;
  setting_wheel.x = width*0.2;
  setting_wheel.y = height/2;

}

function draw() {
  background(255, 0);
  
  encoder.draw();
  setting_wheel.draw();
}

function mousePressed() {
  console.log("touch started")
  if(abs(dist(encoder.x, encoder.y, mouseX, mouseY)) < encoder.size*0.5 ) {
    console.log("pressed encoder");
    encoder.pressed = true;
    encoder.touch_angle = atan2(encoder.x - mouseX, mouseY-encoder.y);
    // prevent default
    return false;
  }
  if(abs(dist(setting_wheel.x, setting_wheel.y, mouseX, mouseY)) < setting_wheel.size*0.5 ) {
    console.log("pressed setting_wheel");
    setting_wheel.pressed = true;
    setting_wheel.touch_angle = atan2(setting_wheel.x - mouseX, mouseY-setting_wheel.y);
    // prevent default
    return false;
  }
  return true;
}
function touchMoved() {
  if(encoder.pressed) {
    encoder.update_rotation(mouseX, mouseY);
    // prevent default
    return false;
  }
  if(setting_wheel.pressed) {
    setting_wheel.update_rotation(mouseX, mouseY);
    // prevent default
    return false;
  }
  return true;
}
function touchEnded() {
  console.log("touch ended")
  encoder.pressed = false;
  setting_wheel.pressed = false;
}
      </script>
  </body>
</html>
